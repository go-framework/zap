// Code generated by protoc-gen-go. DO NOT EDIT.
// source: zap.proto

package zap

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Logger level enum.
// Level should be reduce 1 than equal zap logger level value.
type Level int32

const (
	// DebugLevel logs are typically voluminous, and are usually disabled in
	// production.
	Level_Debug Level = 0
	// InfoLevel is the default logging priority.
	Level_Info Level = 1
	// WarnLevel logs are more important than Info, but don't need individual
	// human review.
	Level_Warn Level = 2
	// ErrorLevel logs are high-priority. If an application is running smoothly,
	// it shouldn't generate any error-level logs.
	Level_Error Level = 3
	// DPanicLevel logs are particularly important errors. In development the
	// logger panics after writing the message.
	Level_DPanic Level = 4
	// PanicLevel logs a message, then panics.
	Level_Panic Level = 5
	// FatalLevel logs a message, then calls os.Exit(1).
	Level_Fatal Level = 6
)

var Level_name = map[int32]string{
	0: "Debug",
	1: "Info",
	2: "Warn",
	3: "Error",
	4: "DPanic",
	5: "Panic",
	6: "Fatal",
}

var Level_value = map[string]int32{
	"Debug":  0,
	"Info":   1,
	"Warn":   2,
	"Error":  3,
	"DPanic": 4,
	"Panic":  5,
	"Fatal":  6,
}

func (x Level) String() string {
	return proto.EnumName(Level_name, int32(x))
}

func (Level) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_500c6d736cd51ba2, []int{0}
}

// Atomic level message.
type AtomicLevel struct {
	Level                Level    `protobuf:"varint,1,opt,name=level,proto3,enum=zap.Level" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AtomicLevel) Reset()         { *m = AtomicLevel{} }
func (m *AtomicLevel) String() string { return proto.CompactTextString(m) }
func (*AtomicLevel) ProtoMessage()    {}
func (*AtomicLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_500c6d736cd51ba2, []int{0}
}

func (m *AtomicLevel) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AtomicLevel.Unmarshal(m, b)
}
func (m *AtomicLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AtomicLevel.Marshal(b, m, deterministic)
}
func (m *AtomicLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicLevel.Merge(m, src)
}
func (m *AtomicLevel) XXX_Size() int {
	return xxx_messageInfo_AtomicLevel.Size(m)
}
func (m *AtomicLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicLevel.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicLevel proto.InternalMessageInfo

func (m *AtomicLevel) GetLevel() Level {
	if m != nil {
		return m.Level
	}
	return Level_Debug
}

// Empty message.
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_500c6d736cd51ba2, []int{1}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("zap.Level", Level_name, Level_value)
	proto.RegisterType((*AtomicLevel)(nil), "zap.AtomicLevel")
	proto.RegisterType((*Empty)(nil), "zap.Empty")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LevelServiceClient is the client API for LevelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LevelServiceClient interface {
	// Get logger atomic Level.
	GetLevel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AtomicLevel, error)
	// Set logger atomic Level.
	SetLevel(ctx context.Context, in *AtomicLevel, opts ...grpc.CallOption) (*Empty, error)
}

type levelServiceClient struct {
	cc *grpc.ClientConn
}

func NewLevelServiceClient(cc *grpc.ClientConn) LevelServiceClient {
	return &levelServiceClient{cc}
}

func (c *levelServiceClient) GetLevel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AtomicLevel, error) {
	out := new(AtomicLevel)
	err := c.cc.Invoke(ctx, "/zap.LevelService/GetLevel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *levelServiceClient) SetLevel(ctx context.Context, in *AtomicLevel, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/zap.LevelService/SetLevel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LevelServiceServer is the server API for LevelService service.
type LevelServiceServer interface {
	// Get logger atomic Level.
	GetLevel(context.Context, *Empty) (*AtomicLevel, error)
	// Set logger atomic Level.
	SetLevel(context.Context, *AtomicLevel) (*Empty, error)
}

func RegisterLevelServiceServer(s *grpc.Server, srv LevelServiceServer) {
	s.RegisterService(&_LevelService_serviceDesc, srv)
}

func _LevelService_GetLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).GetLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zap.LevelService/GetLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).GetLevel(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LevelService_SetLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AtomicLevel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).SetLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zap.LevelService/SetLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).SetLevel(ctx, req.(*AtomicLevel))
	}
	return interceptor(ctx, in, info, handler)
}

var _LevelService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "zap.LevelService",
	HandlerType: (*LevelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLevel",
			Handler:    _LevelService_GetLevel_Handler,
		},
		{
			MethodName: "SetLevel",
			Handler:    _LevelService_SetLevel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "zap.proto",
}

func init() { proto.RegisterFile("zap.proto", fileDescriptor_500c6d736cd51ba2) }

var fileDescriptor_500c6d736cd51ba2 = []byte{
	// 203 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x8f, 0xc1, 0xeb, 0x82, 0x30,
	0x14, 0xc7, 0x7f, 0xfe, 0x74, 0xa6, 0xaf, 0x88, 0xb1, 0x53, 0x78, 0x12, 0x4f, 0xd2, 0xc1, 0xc0,
	0xfe, 0x82, 0x40, 0x8b, 0xa0, 0x43, 0xe4, 0xa1, 0xf3, 0x94, 0x15, 0x82, 0xba, 0x31, 0x96, 0x90,
	0x7f, 0x7d, 0x6c, 0x23, 0x10, 0xba, 0x7d, 0xd8, 0xe7, 0xbd, 0x7d, 0xbf, 0x0f, 0xc2, 0x89, 0x8a,
	0x4c, 0x48, 0xae, 0x38, 0x71, 0x27, 0x2a, 0x92, 0x1d, 0x2c, 0x0f, 0x8a, 0xf7, 0x6d, 0x73, 0x61,
	0x23, 0xeb, 0x48, 0x0c, 0xa8, 0xd3, 0xb0, 0x71, 0x62, 0x27, 0x5d, 0xe7, 0x90, 0xe9, 0x71, 0xa3,
	0x6e, 0x56, 0x24, 0x0b, 0x40, 0x65, 0x2f, 0xd4, 0x7b, 0x5b, 0x01, 0xb2, 0x3b, 0x21, 0xa0, 0x82,
	0xd5, 0xaf, 0x27, 0xfe, 0x23, 0x01, 0x78, 0xe7, 0xe1, 0xc1, 0xb1, 0xa3, 0xe9, 0x4e, 0xe5, 0x80,
	0xff, 0xb5, 0x2e, 0xa5, 0xe4, 0x12, 0xbb, 0x04, 0xc0, 0x2f, 0xae, 0x74, 0x68, 0x1b, 0xec, 0xe9,
	0x67, 0x8b, 0x48, 0xe3, 0x91, 0x2a, 0xda, 0x61, 0x3f, 0xaf, 0x61, 0x65, 0x3e, 0xad, 0x98, 0x1c,
	0xdb, 0x86, 0x91, 0x14, 0x82, 0x13, 0x53, 0x36, 0xc7, 0x96, 0x31, 0xe1, 0x11, 0x36, 0x3c, 0x6f,
	0x9e, 0x42, 0x50, 0x7d, 0x27, 0x7f, 0x6c, 0x34, 0xdb, 0xad, 0x7d, 0x73, 0xfe, 0xfe, 0x13, 0x00,
	0x00, 0xff, 0xff, 0x1f, 0xeb, 0x3d, 0xe7, 0x0b, 0x01, 0x00, 0x00,
}
